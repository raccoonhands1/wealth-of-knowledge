/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ZhongwenReaderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var VIEW_TYPE_VOCAB_SIDEBAR = "vocab-sidebar";
var DEFAULT_SETTINGS = {
  saveSentences: false
};
var ZhongwenReaderPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.cedictMap = /* @__PURE__ */ new Map();
    this.activeHighlight = null;
    this.activeWord = null;
    this.activeEntries = null;
    this.hoverBoxEl = null;
    this.tooltipEl = null;
    this.refreshVocabSidebar = null;
    // In order to not update vocab list on every keystroke
    this.refreshTimer = null;
    // Save currentMarkdownView so vocab list doesnt disappear when user clicks on vocab sidebar
    this.currentMarkdownView = null;
    // For if the user wants to store the current sentence as an example
    this.activeExampleSentence = null;
    this.hskVocab = /* @__PURE__ */ new Map();
    this.hoverHandlerChars = (event) => {
      var _a, _b;
      const el = event.target;
      const isEditLine = el.closest(".cm-line");
      const isPreviewBlock = (_a = el.closest(".markdown-preview-view")) == null ? void 0 : _a.querySelector(".markdown-preview-sizer");
      const isPreviewTarget = el.closest(".el-p, .el-h1, .el-h2, .el-h3, .el-li, .el-blockquote, .el-table");
      if (!isEditLine && !(isPreviewBlock && isPreviewTarget)) {
        this.hideHoverBox();
        this.hideTooltip();
        return;
      }
      const range = document.caretRangeFromPoint(event.clientX, event.clientY);
      if (!range || range.startContainer.nodeType !== Node.TEXT_NODE) {
        this.hideHoverBox();
        this.hideTooltip();
        this.activeHighlight = null;
        this.activeWord = null;
        this.activeEntries = null;
        return;
      }
      const textNode = range.startContainer;
      const offset = range.startOffset;
      const text = (_b = textNode.textContent) != null ? _b : "";
      if (offset < 0 || offset >= text.length) {
        this.hideHoverBox();
        return;
      }
      const chineseChar = /[\u4e00-\u9fff]/;
      if (!chineseChar.test(text[offset])) {
        this.hideHoverBox();
        return;
      }
      const match = this.getForwardMatchedWord(text, offset);
      if (!match) {
        this.hideHoverBox();
        return;
      }
      const start = offset;
      const end = Math.min(match.end, textNode.length);
      const rangeForWord = document.createRange();
      rangeForWord.setStart(textNode, start);
      rangeForWord.setEnd(textNode, end);
      const rect = rangeForWord.getBoundingClientRect();
      if (this.hoverBoxEl) {
        this.hoverBoxEl.style.left = `${rect.left + window.scrollX}px`;
        this.hoverBoxEl.style.top = `${rect.top + window.scrollY}px`;
        this.hoverBoxEl.style.width = `${rect.width}px`;
        this.hoverBoxEl.style.height = `${rect.height}px`;
        this.hoverBoxEl.style.display = "block";
      }
      if (this.settings.saveSentences) {
        const sentence = this.extractSentenceFromTextAtOffset(text, offset, match.word);
        this.activeExampleSentence = sentence;
      }
      this.showTooltipForWord(match.word, rect.left + window.scrollX, rect.top + window.scrollY);
    };
  }
  async onload() {
    await this.loadSettings();
    const pluginFolder = `${this.app.vault.configDir}/plugins/${this.manifest.id}`;
    const dictPath = pluginFolder + "/cedict_ts.u8";
    const cedictExists = await this.app.vault.adapter.exists(dictPath);
    if (!cedictExists) {
      new import_obsidian.Notice(`Downloading CEDICT...`);
      try {
        const url = "https://raw.githubusercontent.com/natipt/obsidian-zhongwen-reader/main/cedict_ts.u8";
        const res = await (0, import_obsidian.requestUrl)({ url });
        await this.app.vault.adapter.writeBinary(dictPath, res.arrayBuffer);
        new import_obsidian.Notice(`Download complete!`);
      } catch (err) {
        console.error("Failed to download cedict_ts.u8", err);
        new import_obsidian.Notice("Failed to download CEDICT.");
      }
    }
    const hskPath = pluginFolder + "/hsk-vocab.json";
    const hskExists = await this.app.vault.adapter.exists(hskPath);
    if (!hskExists) {
      new import_obsidian.Notice("Downloading HSK vocab...");
      try {
        const hskUrl = "https://raw.githubusercontent.com/natipt/obsidian-zhongwen-reader/main/hsk-vocab.json";
        const hskRes = await (0, import_obsidian.requestUrl)({ url: hskUrl });
        await this.app.vault.adapter.write(hskPath, hskRes.text);
        new import_obsidian.Notice("HSK vocab download complete!");
      } catch (err) {
        console.error("Failed to download hsk-vocab.json.");
        new import_obsidian.Notice("Failed to download HSK vocab.");
      }
    }
    const vocabPath = pluginFolder + "/vocab.json";
    const vocabExists = await this.app.vault.adapter.exists(vocabPath);
    if (!vocabExists) {
      try {
        await this.app.vault.adapter.write(vocabPath, "");
      } catch (err) {
        console.error("Failed to create vocab.json", err);
      }
    }
    const data = await this.loadDictionaryFile(dictPath);
    this.loadCedictFromText(data);
    this.hoverBoxEl = document.createElement("div");
    this.hoverBoxEl.className = "cedict-hover-box";
    document.body.appendChild(this.hoverBoxEl);
    this.tooltipEl = document.createElement("div");
    this.tooltipEl.className = "cedict-tooltip";
    document.body.appendChild(this.tooltipEl);
    this.addSettingTab(new ZhongwenReaderSettingTab(this.app, this));
    this.hoverHandler = this.hoverHandlerChars.bind(this);
    document.addEventListener("mousemove", this.hoverHandler);
    this.addCommand({
      id: "save-current-hovered-word",
      name: "Save hovered word to vocab list.",
      checkCallback: (checking) => {
        if (this.activeWord && this.activeEntries) {
          if (!checking) {
            this.addToVocab(this.activeWord, this.activeEntries);
          }
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "export-vocab-flashcards",
      name: "Export Vocab to Flashcards",
      callback: () => this.exportVocabToFlashcards()
    });
    this.registerView(
      VIEW_TYPE_VOCAB_SIDEBAR,
      (leaf) => new VocabSidebarView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Open Vocab Sidebar", async () => {
      await this.activateView();
    });
    this.app.workspace.onLayoutReady(() => {
      this.activateView();
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          this.currentMarkdownView = view;
          this.triggerSidebarRefresh();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        if (this.refreshTimer) window.clearTimeout(this.refreshTimer);
        this.refreshTimer = window.setTimeout(() => {
          const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
          if (view) {
            this.currentMarkdownView = view;
            this.triggerSidebarRefresh();
          }
        }, 300);
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view) {
          this.currentMarkdownView = view;
          this.triggerSidebarRefresh();
        }
      })
    );
    await this.loadHSKVocab();
    this.addCommand({
      id: "highlight-hsk-words",
      name: "Highlight all HSK words in current note..",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-1-words",
      name: "Highlight HSK 1 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 1);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-2-words",
      name: "Highlight HSK 2 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 2);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-3-words",
      name: "Highlight HSK 3 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 3);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-4-words",
      name: "Highlight HSK 4 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 4);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-5-words",
      name: "Highlight HSK 5 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 5);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "highlight-hsk-6-words",
      name: "Highlight HSK 6 words in current note.",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.highlightHSKWords(view.editor, 6);
          return true;
        }
        return false;
      }
    });
    this.addCommand({
      id: "clear-hsk-highlights",
      name: "Clear HSK Highlights in Current Note",
      checkCallback: (checking) => {
        const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (view && view.editor) {
          if (!checking) this.clearHSKHighlights(view.editor);
          return true;
        }
        return false;
      }
    });
  }
  onunload() {
    document.removeEventListener("mousemove", this.hoverHandler);
    if (this.activeHighlight) {
      const parent = this.activeHighlight.parentNode;
      if (parent) {
        parent.replaceChild(
          document.createTextNode(this.activeHighlight.innerText),
          this.activeHighlight
        );
      }
      this.activeHighlight = null;
    }
    if (this.hoverBoxEl) {
      this.hoverBoxEl.remove();
      this.hoverBoxEl = null;
    }
    if (this.tooltipEl) {
      this.tooltipEl.style.display = "none";
      this.tooltipEl.remove();
      this.tooltipEl = null;
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async loadDictionaryFile(fileName) {
    const arrayBuffer = await this.app.vault.adapter.readBinary(fileName);
    const decoder = new TextDecoder("utf-8");
    return decoder.decode(arrayBuffer);
  }
  parseCedictLine(line) {
    const match = line.match(/^(\S+)\s+(\S+)\s+\[(.+?)\]\s+\/(.+)\//);
    if (!match) return null;
    const [, trad, simp, pinyin, defs] = match;
    return {
      traditional: trad,
      simplified: simp,
      pinyin,
      definitions: defs.split("/")
    };
  }
  loadCedictFromText(cedictText) {
    const lines = cedictText.split("\n");
    for (const line of lines) {
      if (line.startsWith("#") || line.trim() === "") continue;
      const entry = this.parseCedictLine(line);
      if (entry) {
        [entry.traditional, entry.simplified].forEach((form) => {
          if (!this.cedictMap.has(form)) this.cedictMap.set(form, []);
          this.cedictMap.get(form).push(entry);
        });
      }
    }
  }
  async loadHSKVocab() {
    const path = (0, import_obsidian.normalizePath)(`${this.app.vault.configDir}/plugins/${this.manifest.id}/hsk-vocab.json`);
    try {
      const content = await this.app.vault.adapter.read(path);
      const data = JSON.parse(content);
      for (const [level, words] of Object.entries(data)) {
        this.hskVocab.set(Number(level), new Set(words));
      }
    } catch (err) {
      console.error("Failed to load HSK vocab:", err);
    }
  }
  highlightHSKWords(editor, specificLevel) {
    var _a;
    const text = editor.getValue();
    let modifiedText;
    let alreadyHighlighted = /* @__PURE__ */ new Set();
    if (specificLevel === void 0) {
      modifiedText = text.replace(/<span class="hsk-highlight hsk-level-\d+">(.+?)<\/span>/g, "$1");
      this.clearHSKHighlights(editor);
    } else {
      modifiedText = text;
      const matches = modifiedText.matchAll(/<span class="hsk-highlight hsk-level-\d+">(.+?)<\/span>/g);
      for (const match of matches) {
        if (match[1]) alreadyHighlighted.add(match[1]);
      }
    }
    const levels = specificLevel ? [specificLevel] : Array.from(this.hskVocab.keys()).sort((a, b) => Number(a) - Number(b));
    for (const level of levels) {
      const words = (_a = this.hskVocab.get(level)) != null ? _a : [];
      for (const word of words) {
        if (alreadyHighlighted.has(word)) continue;
        const escapedWord = word.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
        const regex = new RegExp(escapedWord, "g");
        modifiedText = modifiedText.replace(regex, (match) => {
          alreadyHighlighted.add(match);
          return `<span class="hsk-highlight hsk-level-${level}">${match}</span>`;
        });
      }
    }
    editor.setValue(modifiedText);
  }
  clearHSKHighlights(editor) {
    let text = editor.getValue();
    let previous;
    do {
      previous = text;
      text = text.replace(/<span class="hsk-highlight hsk-level-\d+">([^<>]*)<\/span>/g, "$1");
    } while (text !== previous);
    editor.setValue(text);
  }
  hideHoverBox() {
    if (this.hoverBoxEl) {
      this.hoverBoxEl.style.display = "none";
    }
  }
  getForwardMatchedWord(text, offset) {
    const maxWordLen = 5;
    const substr = text.slice(offset, offset + maxWordLen);
    for (let len = maxWordLen; len > 0; len--) {
      const candidate = substr.slice(0, len);
      if (this.cedictMap.has(candidate)) {
        return { word: candidate, end: offset + len };
      }
    }
    return null;
  }
  showTooltipForWord(word, x, y) {
    if (!this.tooltipEl) return;
    const entries = this.cedictMap.get(word);
    if (!entries || entries.length === 0) {
      this.tooltipEl.style.display = "none";
      return;
    }
    const seen = /* @__PURE__ */ new Set();
    const uniqueEntries = entries.filter((entry) => {
      const id = `${entry.traditional}-${entry.simplified}-${entry.pinyin}-${entry.definitions.join(",")}`;
      if (seen.has(id)) return false;
      seen.add(id);
      return true;
    });
    this.activeWord = word;
    this.activeEntries = uniqueEntries;
    const text = uniqueEntries.map(
      (entry) => `${entry.simplified} ${entry.simplified !== entry.traditional ? entry.traditional : ""} (${this.processPinyin(entry.pinyin)})
${entry.definitions.join("; ")}`
    ).join("\n\n");
    this.tooltipEl.innerText = text;
    if (!this.hoverBoxEl) return;
    const hoverRect = this.hoverBoxEl.getBoundingClientRect();
    this.tooltipEl.style.left = `${hoverRect.left + window.scrollX}px`;
    this.tooltipEl.style.top = `${hoverRect.bottom + window.scrollY + 4}px`;
    this.tooltipEl.style.display = "block";
  }
  processPinyin(pinyin) {
    const toneMap = {
      "a": ["\u0101", "\xE1", "\u01CE", "\xE0", "a"],
      "e": ["\u0113", "\xE9", "\u011B", "\xE8", "e"],
      "i": ["\u012B", "\xED", "\u01D0", "\xEC", "i"],
      "o": ["\u014D", "\xF3", "\u01D2", "\xF2", "o"],
      "u": ["\u016B", "\xFA", "\u01D4", "\xF9", "u"],
      "\xFC": ["\u01D6", "\u01D8", "\u01DA", "\u01DC", "\xFC"]
    };
    const vowels = ["a", "o", "e", "i", "u", "\xFC"];
    return pinyin.split(" ").map((syllable) => {
      const tone = parseInt(syllable[syllable.length - 1]);
      if (tone < 1 || tone > 5) return syllable;
      let core = syllable.slice(0, -1);
      let vowelToReplace = "";
      for (const v of vowels) {
        if (core.includes(v)) {
          vowelToReplace = v;
          break;
        }
      }
      if (!vowelToReplace) return syllable;
      const accented = toneMap[vowelToReplace][tone - 1];
      const regex = new RegExp(vowelToReplace + "(?!.*" + vowelToReplace + ")", "g");
      core = core.replace(regex, accented);
      return core;
    }).join(" ");
  }
  hideTooltip() {
    if (this.tooltipEl) {
      this.tooltipEl.style.display = "none";
    }
  }
  async addToVocab(word, entries) {
    var _a, _b, _c, _d;
    const path = (0, import_obsidian.normalizePath)(`${this.app.vault.configDir}/plugins/${this.manifest.id}/vocab.json`);
    let list = [];
    try {
      const file = await this.app.vault.adapter.read(path);
      list = JSON.parse(file);
    } catch (e) {
      list = [];
    }
    const newSentence = (((_a = this.activeExampleSentence) == null ? void 0 : _a.trim()) === word ? "" : (_b = this.activeExampleSentence) == null ? void 0 : _b.trim()) || "";
    const existingEntry = list.find((e) => e.simplified === word);
    if (existingEntry) {
      if (this.settings.saveSentences && newSentence) {
        if (!existingEntry.exampleSentences) existingEntry.exampleSentences = [];
        if (!existingEntry.exampleSentences.includes(newSentence)) {
          existingEntry.exampleSentences.push(newSentence);
          await this.app.vault.adapter.write(path, JSON.stringify(list, null, 2));
          new import_obsidian.Notice(`Added new sentence to ${word}.`);
        } else {
          new import_obsidian.Notice(`${word} is already in your vocab list.`);
        }
      } else {
        new import_obsidian.Notice(`${word} is already in your vocab list.`);
      }
      this.activeExampleSentence = null;
      (_c = this.refreshVocabSidebar) == null ? void 0 : _c.call(this);
      return;
    }
    const allDefs = entries.flatMap((e) => e.definitions);
    const uniqueDefs = Array.from(new Set(allDefs));
    const rep = entries[0];
    const newEntry = {
      simplified: rep.simplified,
      traditional: rep.traditional,
      pinyin: rep.pinyin,
      definitions: uniqueDefs,
      addedAt: (/* @__PURE__ */ new Date()).toISOString(),
      ...this.settings.saveSentences && this.activeExampleSentence ? { exampleSentences: [this.activeExampleSentence] } : {}
    };
    list.push(newEntry);
    await this.app.vault.adapter.write(path, JSON.stringify(list, null, 2));
    new import_obsidian.Notice(`Added ${word} to vocab list!`);
    (_d = this.refreshVocabSidebar) == null ? void 0 : _d.call(this);
    this.activeExampleSentence = null;
  }
  async exportVocabToFlashcards() {
    const path = (0, import_obsidian.normalizePath)(`${this.app.vault.configDir}/plugins/${this.manifest.id}/vocab.json`);
    const outputPath = `Obsidian-Zhongwen-Reader-Vocab-Deck.md`;
    let list = [];
    try {
      const file = await this.app.vault.adapter.read(path);
      list = JSON.parse(file);
    } catch (e) {
      new import_obsidian.Notice("No vocab list found.");
      return;
    }
    const lines = list.map((entry) => {
      const defs = entry.definitions.join("; ");
      return `${entry.simplified}::${defs}`;
    });
    const content = `#ChineseVocab

${lines.join("\n\n")}`;
    await this.app.vault.adapter.write(outputPath, content);
    new import_obsidian.Notice("Exported vocab to flashcard deck!");
  }
  extractSentenceFromTextAtOffset(text, offset, word) {
    var _a;
    if (!this.settings.saveSentences) return "";
    const punctuation = /[。！？!?]/;
    let start = offset;
    while (start > 0 && !punctuation.test(text[start - 1])) {
      start--;
    }
    let end = offset;
    while (end < text.length && !punctuation.test(text[end])) {
      end++;
    }
    if (end < text.length) end++;
    const sentence = text.slice(start, end).trim();
    if (!sentence || !sentence.includes(word)) {
      const line = (_a = text.split("\n").find((l) => l.includes(word))) != null ? _a : text;
      if (line.trim() === word) return "";
      return line.trim();
    }
    return sentence;
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_VOCAB_SIDEBAR);
    if (leaves.length === 0) {
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: VIEW_TYPE_VOCAB_SIDEBAR,
        active: true
      });
    }
    this.app.workspace.revealLeaf(
      this.app.workspace.getLeavesOfType(VIEW_TYPE_VOCAB_SIDEBAR)[0]
    );
  }
  // needs to be accessed by VocabSidebarView
  async loadVocabList() {
    const path = (0, import_obsidian.normalizePath)(`${this.app.vault.configDir}/plugins/${this.manifest.id}/vocab.json`);
    try {
      const file = await this.app.vault.adapter.read(path);
      return JSON.parse(file);
    } catch (e) {
      return [];
    }
  }
  // Refresh timer so sidebar doesnt get double rendered when I switch leaves
  triggerSidebarRefresh() {
    if (this.refreshTimer) window.clearTimeout(this.refreshTimer);
    this.refreshTimer = window.setTimeout(async () => {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_VOCAB_SIDEBAR);
      for (const leaf of leaves) {
        const view = leaf.view;
        if (view instanceof VocabSidebarView) {
          await view.renderSidebar();
        }
      }
    }, 100);
  }
  scrollToWordInActiveFile(word) {
    var _a, _b, _c;
    const view = this.currentMarkdownView;
    const mode = (_b = (_a = view == null ? void 0 : view.getMode) == null ? void 0 : _a.call(view)) != null ? _b : "source";
    if (!view) {
      console.warn("No active Markdown view");
      return;
    }
    let scroller;
    if (mode === "source") {
      scroller = view.containerEl.querySelector(".cm-scroller");
    } else {
      scroller = view.containerEl.querySelector(".markdown-preview-sizer");
    }
    if (!scroller) return;
    let lines;
    if (mode === "source") {
      lines = scroller.querySelectorAll(".cm-line");
    } else {
      lines = scroller.querySelectorAll(
        ".el-p, .el-h1, .el-h2, .el-h3, .el-li, .el-blockquote, .el-table"
      );
    }
    for (const line of Array.from(lines)) {
      if ((_c = line.textContent) == null ? void 0 : _c.includes(word)) {
        line.scrollIntoView({ behavior: "smooth", block: "center" });
        setTimeout(() => {
          line.classList.add("cedict-line-hover");
          setTimeout(() => {
            line.classList.remove("cedict-line-hover");
          }, 1500);
        }, 100);
        break;
      }
    }
  }
};
var VocabSidebarView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
  }
  getViewType() {
    return VIEW_TYPE_VOCAB_SIDEBAR;
  }
  getDisplayText() {
    return "Vocabulary";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    const container = this.containerEl;
    container.querySelectorAll(".vocab-entry").forEach((el) => el.remove());
    this.plugin.refreshVocabSidebar = () => this.renderSidebar();
    await this.waitForView();
    await this.renderSidebar();
  }
  async onClose() {
    this.plugin.refreshVocabSidebar = null;
  }
  async waitForView() {
    let retries = 10;
    while (!this.plugin.currentMarkdownView && retries-- > 0) {
      await new Promise((resolve) => setTimeout(resolve, 100));
    }
  }
  async renderSidebar() {
    var _a, _b, _c, _d;
    const container = this.containerEl.children[1];
    container.empty();
    const vocabList = await this.plugin.loadVocabList();
    const view = this.plugin.currentMarkdownView;
    const currentFileText = (view == null ? void 0 : view.editor) ? view.editor.getValue() : (_a = view == null ? void 0 : view.contentEl.textContent) != null ? _a : "";
    const matchingVocab = vocabList.filter(
      (entry) => currentFileText.includes(entry.simplified) || currentFileText.includes(entry.traditional)
    );
    container.createEl("h3", {
      text: "Vocab in this note",
      cls: "vocab-heading"
    });
    if (!matchingVocab.length) {
      container.createEl("p", { text: "No vocab yet." });
      return;
    }
    for (const entry of matchingVocab) {
      const wrapper = container.createEl("div", { cls: "vocab-entry" });
      wrapper.createEl("div", {
        text: `${entry.simplified} ${entry.simplified !== entry.traditional ? "(" + entry.traditional + ")" : ""}`,
        cls: "vocab-word"
      });
      wrapper.createEl("div", {
        text: (_d = (_c = this.plugin).processPinyin) == null ? void 0 : _d.call(_c, (_b = entry.pinyin) != null ? _b : ""),
        cls: "vocab-pinyin"
      });
      wrapper.createEl("div", {
        text: entry.definitions.join(";\n "),
        cls: "vocab-defs"
      });
      wrapper.onclick = () => {
        this.plugin.scrollToWordInActiveFile(entry.simplified);
      };
    }
  }
};
var ZhongwenReaderSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Save example sentences").setDesc("When saving a vocab word, also store the sentence it appears in.").addToggle((toggle) => toggle.setValue(this.plugin.settings.saveSentences).onChange(async (value) => {
      this.plugin.settings.saveSentences = value;
      await this.plugin.saveSettings();
    }));
  }
};

/* nosourcemap */